//
//  crypt_b64.c
//  mchat_server
//
//  Created by Noah Wooten on 1/26/24.
//

#include "crypt.h"
#include <string.h>

// Found here: (private repository)
// https://github.com/noahw2021/triacto/blob/master/backend/crypt/base64.c
/*
 Probably not my best work. - nw 1/26/24
 base64.c - Last Modified Jan 13 2022
 */

const char Alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
BYTE InverseBet[0x50] = {
    0x3E, 0x40, 0x40, 0x40, 0x3F, 0x34, 0x35, 0x36, 
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x40, 
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x01,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
    0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x1A, 0x1B,
    0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B,
    0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33
};

WORD32 Crypt_B64Size(BYTE* Data, WORD32 Size) {
    if (!Data) {
        WORD32 Return = 0;
        Return = Size;
        if (Size % 3 != 0)
                Return += 3 - (Size % 3);
        
        Return /= 3;
        Return *= 4;
        return Return + 1;
    } else {
        WORD32 Return;
        WORD32 StrLength = strlen((char*)Data);
        Return = (StrLength / 4) * 3;
            
        for (int i = 0; i < StrLength; i++) {
                if (Data[i] == 0x3D)
                    Return--;
        }
        
        return Return;
    }
}

char* CryptEncodeBase64(void* Data, WORD32 DataSize) {
    
    
    return NULL;
}
